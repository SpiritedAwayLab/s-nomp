{
    "sourceFile": "libs/poolWorker.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1667805439618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1667805446749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,8 +139,9 @@\n                 else {\r\n                     console.info(\"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\")\r\n                     console.info(workerName)\r\n                     pool.daemon.cmd('validateaddress', [String(workerName).split(\".\")[0]], function (results) {\r\n+                        console.info(results)\r\n                         var isValid = results.filter(function (r) {\r\n                             return r.response.isvalid\r\n                         }).length > 0;\r\n                         authCallback(isValid);\r\n"
                },
                {
                    "date": 1667805841064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -154,8 +154,13 @@\n             };\r\n         }\r\n \r\n         var authorizeFN = function (ip, port, workerName, password, callback) {\r\n+            console.info(\"authorizeFN\")\r\n+            console.info(ip)\r\n+            console.info(port)\r\n+            console.info(workerName)\r\n+            console.info(password)\r\n             handlers.auth(port, workerName, password, function (authorized) {\r\n \r\n                 var authString = authorized ? 'Authorized' : 'Unauthorized ';\r\n \r\n"
                }
            ],
            "date": 1667805439618,
            "name": "Commit-0",
            "content": "var Stratum = require('stratum-pool');\r\nvar redis = require('redis');\r\nvar net = require('net');\r\n\r\nvar MposCompatibility = require('./mposCompatibility.js');\r\nvar ShareProcessor = require('./shareProcessor.js');\r\nvar CreateRedisClient = require('./createRedisClient.js');\r\n\r\nmodule.exports = function (logger) {\r\n\r\n    var _this = this;\r\n\r\n    var poolConfigs = JSON.parse(process.env.pools);\r\n    var portalConfig = JSON.parse(process.env.portalConfig);\r\n\r\n    var forkId = process.env.forkId;\r\n\r\n    var pools = {};\r\n\r\n    var proxySwitch = {};\r\n\r\n    var redisClient = CreateRedisClient(portalConfig.redis);\r\n    if (portalConfig.redis.password) {\r\n        redisClient.auth(portalConfig.redis.password);\r\n    }\r\n    //Handle messages from master process sent via IPC\r\n    process.on('message', function (message) {\r\n        switch (message.type) {\r\n\r\n            case 'banIP':\r\n                for (var p in pools) {\r\n                    if (pools[p].stratumServer)\r\n                        pools[p].stratumServer.addBannedIP(message.ip);\r\n                }\r\n                break;\r\n\r\n            case 'blocknotify':\r\n\r\n                var messageCoin = message.coin.toLowerCase();\r\n                var poolTarget = Object.keys(pools).filter(function (p) {\r\n                    return p.toLowerCase() === messageCoin;\r\n                })[0];\r\n\r\n                if (poolTarget)\r\n                    pools[poolTarget].processBlockNotify(message.hash, 'blocknotify script');\r\n\r\n                break;\r\n\r\n            // IPC message for pool switching\r\n            case 'coinswitch':\r\n                var logSystem = 'Proxy';\r\n                var logComponent = 'Switch';\r\n                var logSubCat = 'Thread ' + (parseInt(forkId) + 1);\r\n\r\n                var switchName = message.switchName;\r\n\r\n                var newCoin = message.coin;\r\n\r\n                var algo = poolConfigs[newCoin].coin.algorithm;\r\n\r\n                var newPool = pools[newCoin];\r\n                var oldCoin = proxySwitch[switchName].currentPool;\r\n                var oldPool = pools[oldCoin];\r\n                var proxyPorts = Object.keys(proxySwitch[switchName].ports);\r\n\r\n                if (newCoin == oldCoin) {\r\n                    logger.debug(logSystem, logComponent, logSubCat, 'Switch message would have no effect - ignoring ' + newCoin);\r\n                    break;\r\n                }\r\n\r\n                logger.debug(logSystem, logComponent, logSubCat, 'Proxy message for ' + algo + ' from ' + oldCoin + ' to ' + newCoin);\r\n\r\n                if (newPool) {\r\n                    oldPool.relinquishMiners(\r\n                        function (miner, cback) {\r\n                            // relinquish miners that are attached to one of the \"Auto-switch\" ports and leave the others there.\r\n                            cback(proxyPorts.indexOf(miner.client.socket.localPort.toString()) !== -1)\r\n                        },\r\n                        function (clients) {\r\n                            newPool.attachMiners(clients);\r\n                        }\r\n                    );\r\n                    proxySwitch[switchName].currentPool = newCoin;\r\n\r\n                    redisClient.hset('proxyState', algo, newCoin, function (error, obj) {\r\n                        if (error) {\r\n                            logger.error(logSystem, logComponent, logSubCat, 'Redis error writing proxy config: ' + JSON.stringify(err))\r\n                        }\r\n                        else {\r\n                            logger.debug(logSystem, logComponent, logSubCat, 'Last proxy state saved to redis for ' + algo);\r\n                        }\r\n                    });\r\n\r\n                }\r\n                break;\r\n        }\r\n    });\r\n\r\n\r\n    Object.keys(poolConfigs).forEach(function (coin) {\r\n\r\n        var poolOptions = poolConfigs[coin];\r\n\r\n        var logSystem = 'Pool';\r\n        var logComponent = coin;\r\n        var logSubCat = 'Thread ' + (parseInt(forkId) + 1);\r\n\r\n        var handlers = {\r\n            auth: function () { },\r\n            share: function () { },\r\n            diff: function () { }\r\n        };\r\n\r\n        //Functions required for MPOS compatibility\r\n        if (poolOptions.mposMode && poolOptions.mposMode.enabled) {\r\n            var mposCompat = new MposCompatibility(logger, poolOptions);\r\n\r\n            handlers.auth = function (port, workerName, password, authCallback) {\r\n                mposCompat.handleAuth(workerName, password, authCallback);\r\n            };\r\n\r\n            handlers.share = function (isValidShare, isValidBlock, data) {\r\n                mposCompat.handleShare(isValidShare, isValidBlock, data);\r\n            };\r\n\r\n            handlers.diff = function (workerName, diff) {\r\n                mposCompat.handleDifficultyUpdate(workerName, diff);\r\n            }\r\n        }\r\n\r\n        //Functions required for internal payment processing\r\n        else {\r\n\r\n            var shareProcessor = new ShareProcessor(logger, poolOptions);\r\n\r\n            handlers.auth = function (port, workerName, password, authCallback) {\r\n                if (poolOptions.validateWorkerUsername !== true)\r\n                    authCallback(true);\r\n                else {\r\n                    console.info(\"vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\")\r\n                    console.info(workerName)\r\n                    pool.daemon.cmd('validateaddress', [String(workerName).split(\".\")[0]], function (results) {\r\n                        var isValid = results.filter(function (r) {\r\n                            return r.response.isvalid\r\n                        }).length > 0;\r\n                        authCallback(isValid);\r\n                    });\r\n                }\r\n            };\r\n\r\n            handlers.share = function (isValidShare, isValidBlock, data) {\r\n                shareProcessor.handleShare(isValidShare, isValidBlock, data);\r\n            };\r\n        }\r\n\r\n        var authorizeFN = function (ip, port, workerName, password, callback) {\r\n            handlers.auth(port, workerName, password, function (authorized) {\r\n\r\n                var authString = authorized ? 'Authorized' : 'Unauthorized ';\r\n\r\n                logger.debug(logSystem, logComponent, logSubCat, authString + ' ' + workerName + ':' + password + ' [' + ip + ']');\r\n                callback({\r\n                    error: null,\r\n                    authorized: authorized,\r\n                    disconnect: false\r\n                });\r\n            });\r\n        };\r\n\r\n\r\n        var pool = Stratum.createPool(poolOptions, authorizeFN, logger);\r\n        pool.on('share', function (isValidShare, isValidBlock, data) {\r\n\r\n            var shareData = JSON.stringify(data);\r\n\r\n            if (data.blockHash && !isValidBlock)\r\n                logger.debug(logSystem, logComponent, logSubCat, 'We thought a block was found but it was rejected by the daemon, share data: ' + shareData);\r\n\r\n            else if (isValidBlock)\r\n                logger.debug(logSystem, logComponent, logSubCat, 'Block found: ' + data.blockHash + ' by ' + data.worker);\r\n\r\n            if (isValidShare) {\r\n                if (data.shareDiff > 1000000000) {\r\n                    logger.debug(logSystem, logComponent, logSubCat, 'Share was found with diff higher than 1.000.000.000!');\r\n                } else if (data.shareDiff > 1000000) {\r\n                    logger.debug(logSystem, logComponent, logSubCat, 'Share was found with diff higher than 1.000.000!');\r\n                }\r\n                //logger.debug(logSystem, logComponent, logSubCat, 'Share accepted at diff ' + data.difficulty + '/' + data.shareDiff + ' by ' + data.worker + ' [' + data.ip + ']' );\r\n            } else if (!isValidShare) {\r\n                logger.debug(logSystem, logComponent, logSubCat, 'Share rejected: ' + shareData);\r\n            }\r\n\r\n            // handle the share\r\n            handlers.share(isValidShare, isValidBlock, data);\r\n\r\n            // send to master for pplnt time tracking\r\n            process.send({ type: 'shareTrack', thread: (parseInt(forkId) + 1), coin: poolOptions.coin.name, isValidShare: isValidShare, isValidBlock: isValidBlock, data: data });\r\n\r\n        }).on('difficultyUpdate', function (workerName, diff) {\r\n            logger.debug(logSystem, logComponent, logSubCat, 'Difficulty update to diff ' + diff + ' workerName=' + JSON.stringify(workerName));\r\n            handlers.diff(workerName, diff);\r\n        }).on('log', function (severity, text) {\r\n            logger[severity](logSystem, logComponent, logSubCat, text);\r\n        }).on('banIP', function (ip, worker) {\r\n            process.send({ type: 'banIP', ip: ip });\r\n        }).on('started', function () {\r\n            _this.setDifficultyForProxyPort(pool, poolOptions.coin.name, poolOptions.coin.algorithm);\r\n        });\r\n\r\n        pool.start();\r\n        pools[poolOptions.coin.name] = pool;\r\n    });\r\n\r\n\r\n    if (portalConfig.switching) {\r\n\r\n        var logSystem = 'Switching';\r\n        var logComponent = 'Setup';\r\n        var logSubCat = 'Thread ' + (parseInt(forkId) + 1);\r\n\r\n        var proxyState = {};\r\n\r\n        //\r\n        // Load proxy state for each algorithm from redis which allows NOMP to resume operation\r\n        // on the last pool it was using when reloaded or restarted\r\n        //\r\n        logger.debug(logSystem, logComponent, logSubCat, 'Loading last proxy state from redis');\r\n\r\n\r\n\r\n        /*redisClient.on('error', function(err){\r\n            logger.debug(logSystem, logComponent, logSubCat, 'Pool configuration failed: ' + err);\r\n        });*/\r\n\r\n        redisClient.hgetall(\"proxyState\", function (error, obj) {\r\n            if (!error && obj) {\r\n                proxyState = obj;\r\n                logger.debug(logSystem, logComponent, logSubCat, 'Last proxy state loaded from redis');\r\n            }\r\n\r\n            //\r\n            // Setup proxySwitch object to control proxy operations from configuration and any restored\r\n            // state.  Each algorithm has a listening port, current coin name, and an active pool to\r\n            // which traffic is directed when activated in the config.\r\n            //\r\n            // In addition, the proxy config also takes diff and varDiff parmeters the override the\r\n            // defaults for the standard config of the coin.\r\n            //\r\n            Object.keys(portalConfig.switching).forEach(function (switchName) {\r\n\r\n                var algorithm = portalConfig.switching[switchName].algorithm;\r\n\r\n                if (!portalConfig.switching[switchName].enabled) return;\r\n\r\n\r\n                var initalPool = proxyState.hasOwnProperty(algorithm) ? proxyState[algorithm] : _this.getFirstPoolForAlgorithm(algorithm);\r\n                proxySwitch[switchName] = {\r\n                    algorithm: algorithm,\r\n                    ports: portalConfig.switching[switchName].ports,\r\n                    currentPool: initalPool,\r\n                    servers: []\r\n                };\r\n\r\n\r\n                Object.keys(proxySwitch[switchName].ports).forEach(function (port) {\r\n                    var f = net.createServer(function (socket) {\r\n                        var currentPool = proxySwitch[switchName].currentPool;\r\n\r\n                        logger.debug(logSystem, 'Connect', logSubCat, 'Connection to '\r\n                            + switchName + ' from '\r\n                            + socket.remoteAddress + ' on '\r\n                            + port + ' routing to ' + currentPool);\r\n\r\n                        if (pools[currentPool])\r\n                            pools[currentPool].getStratumServer().handleNewClient(socket);\r\n                        else\r\n                            pools[initalPool].getStratumServer().handleNewClient(socket);\r\n\r\n                    }).listen(parseInt(port), function () {\r\n                        logger.debug(logSystem, logComponent, logSubCat, 'Switching \"' + switchName\r\n                            + '\" listening for ' + algorithm\r\n                            + ' on port ' + port\r\n                            + ' into ' + proxySwitch[switchName].currentPool);\r\n                    });\r\n                    proxySwitch[switchName].servers.push(f);\r\n                });\r\n\r\n            });\r\n        });\r\n    }\r\n\r\n    this.getFirstPoolForAlgorithm = function (algorithm) {\r\n        var foundCoin = \"\";\r\n        Object.keys(poolConfigs).forEach(function (coinName) {\r\n            if (poolConfigs[coinName].coin.algorithm == algorithm) {\r\n                if (foundCoin === \"\")\r\n                    foundCoin = coinName;\r\n            }\r\n        });\r\n        return foundCoin;\r\n    };\r\n\r\n    //\r\n    // Called when stratum pool emits its 'started' event to copy the initial diff and vardiff \r\n    // configuation for any proxy switching ports configured into the stratum pool object.\r\n    //\r\n    this.setDifficultyForProxyPort = function (pool, coin, algo) {\r\n\r\n        logger.debug(logSystem, logComponent, algo, 'Setting proxy difficulties after pool start');\r\n\r\n        Object.keys(portalConfig.switching).forEach(function (switchName) {\r\n            if (!portalConfig.switching[switchName].enabled) return;\r\n\r\n            var switchAlgo = portalConfig.switching[switchName].algorithm;\r\n            if (pool.options.coin.algorithm !== switchAlgo) return;\r\n\r\n            // we know the switch configuration matches the pool's algo, so setup the diff and \r\n            // vardiff for each of the switch's ports\r\n            for (var port in portalConfig.switching[switchName].ports) {\r\n\r\n                if (portalConfig.switching[switchName].ports[port].varDiff)\r\n                    pool.setVarDiff(port, portalConfig.switching[switchName].ports[port].varDiff);\r\n\r\n                if (portalConfig.switching[switchName].ports[port].diff) {\r\n                    if (!pool.options.ports.hasOwnProperty(port))\r\n                        pool.options.ports[port] = {};\r\n                    pool.options.ports[port].diff = portalConfig.switching[switchName].ports[port].diff;\r\n                }\r\n            }\r\n        });\r\n    };\r\n};\r\n"
        }
    ]
}